---
layouts: default
title: Scala_Note_1
---

<h2>Scala_Note_1</h2>


<pre>
	
1 class 中调用类的伴生对象（object）方法时需要加类名
2 理解var&val VS mutable&immutable的区别
3 理解lazy val.若一个耗时方法被声明为lazy val,则调用该方法的所有方法尽量声明为lazy val.否则类实例化的时候，还是会计算，似的lazy val失效
4 mutable.Map can not cast to immutable.Map
5 Description	Resource	Path	Location	Type
          type mismatch;  found   : item_id.type (with underlying type String)  required: _1	UserMap.scala	/TmallData/src/weejang	line 68	Scala Problem

6 xml: xml 在2.11以后的系列中，都将被作为一个独立的jar引入．
　　refer: http://stackoverflow.com/questions/22223304/how-will-xml-modularisation-in-scala-2-11-play-with-xml-literals

7 @符号的作用：
---1
//绑定匹配变量

     val list = List(User("jangwee",11),1,User("Liuhuapeng",33),4)
     val seeList = for{
       elem @ User(_,_) <- list
     }yield (elem)
     
     println(seeList)    

//output : 
//    List(User(jangwee,11), User(Liuhuapeng,33))





8 sbt 拉取下来的库位置
　～/.ivy/cache

9 akka 需要引入　config.jar 
com.typesafe.
   refer : http://stackoverflow.com/questions/26052261/bad-symbolic-reference-in-scala-ide-for-eclipse

10　　
 过滤数据：


    val wordFrequencies = ("hh", 5) :: ("ww", 2) :: ("aa", 7) :: Nil

    //method1,Tuple2
    def format1(wf: Seq[(String, Int)]): Seq[String] = {
      wf.filter { x => x._2 > 2 && x._2 < 7 }.map { _._1 }
    }

    println(format1(wordFrequencies))//List(hh)

    //method2,模式匹配结构
    def format2(wf: Seq[(String, Int)]): Seq[String] = {
      wf.filter { case (word, count) => count > 2 && count < 7 }.map { case (word, _) => word }
    }

    println(format2(wordFrequencies))//List(hh)
    //method3-1,偏函数
    //    val pf : PartialFunction[(String,Int),String] = {
    //      case (word,freq) if freq > 2 && freq < 7 => word
    //    }

    //method3-2,显式定义偏函数Trait
    val pf = new PartialFunction[(String, Int), String] {
      def apply(wordFrequency: (String, Int)): String = {
        wordFrequency match {
          case (word, count) if count > 2 && count < 7 => word
        }

      }
      def isDefinedAt(wordFrequency: (String, Int)): Boolean = {
        wordFrequency match {
          case (word, count) if count > 2 && count < 7 => true
          case _ => false
        }
      }
    }

    // Compile Okay,RunTime Error
    //  Exception in thread "main" scala.MatchError: (ww,2) (of class scala.Tuple2)
    //println(wordFrequencies.map(pf))

    println(wordFrequencies.map(pf.isDefinedAt(_))) //List(true, false, false)

    println(wordFrequencies.collect(pf)) // List(hh)

11 for-expression
  

val lastNames = List("Jang", "Geng")
    val firstNames = List("Wee", "Jie")

    //for-expression
    val allName = for {
      lastname <- lastNames
      firstname <- firstNames
    } yield lastname + " " + firstname

    println(allName) //List(Jang Wee, Jang Jie, Geng Wee, Geng Jie)

    // == flatMap
    val allName2 = lastNames.flatMap { lastname =>
      firstNames.map { firstname => lastname + " " + firstname }
    }

    println(allName2) //List(Jang Wee, Jang Jie, Geng Wee, Geng Jie)

    // why flatMap ? what happened with Map?
    val allName3 = lastNames.map { lastname =>
      firstNames.map { firstname => lastname + " " + firstname }
    }
    println(allName3) //List(List(Jang Wee, Jang Jie), List(Geng Wee, Geng Jie))
    
    // with Option
    val maybeFirstName = Some("Wee")
    val maybeLastName = None
    val result = for{
      lastname <- maybeLastName
      firstname <- maybeFirstName
    } yield User(lastname,firstname)
    
    println(result) // None

11 异常处理
   

   //类Java方式的异常处理
case class Customer(age: Int)
class Cigarettes
case class UnderAgeException(message: String) extends Exception(message)

object MMain {
  def main(args: Array[String]): Unit = {
    val customer = new Customer(16)
    try{
      buyCigarettes(customer)
    }catch{
      //case UnderAgeException(msg) => println(msg) //Customer must be older than 18 but was 16
      case ex @ UnderAgeException(_) => ex.printStackTrace()
//      qoeAnalyzer.UnderAgeException: Customer must be older than 18 but was 16
//      at qoeAnalyzer.MMain$.buyCigarettes(MMain.scala:35)
//      at qoeAnalyzer.MMain$.main(MMain.scala:25)
//      at qoeAnalyzer.MMain.main(MMain.scala)
    }

  }

  def buyCigarettes(customer: Customer) : Cigarettes = {
    if (customer.age < 18 )
      throw UnderAgeException(s"Customer must be older than 18 but was ${customer.age}")
    else
      new Cigarettes
  }
｝



// 函数式的错误处理　－Try


import scala.util.Random
import scala.util.{ Try,Success, Failure }
import scala.io.StdIn

object MMain {
  def main(args: Array[String]): Unit = {
    
    val result = divide
    result match {
      case Success(v) =>
        println(s"result of is ${v}")
      case Failure(e) =>
        println("You must've divided by zero or entered something that's not an Int. Try again!")
        println(e.getMessage)
    }
    
  }
  
  def divide: Try[Int] = {
    val dividend = Try(StdIn.readLine("Enter an Int that you'd like to divide:\n").toInt)
    val divisor = Try(StdIn.readLine("Enter an Int that you'd like to divide by :\n").toInt)
    
    //Method_1:    for-expression    
//    val problem = for{
//      x <- dividend
//      y <- divisor
//    } yield( x / y )

    //Method_2:    flatMap*N-Map    
    val problem = dividend.flatMap( x => divisor.map { y => (x / y) })
    
    problem
  }
}

:output:

Enter an Int that you'd like to divide:
10
Enter an Int that you'd like to divide by :
3
result of is 3


or

Enter an Int that you'd like to divide:
10
Enter an Int that you'd like to divide by :
0
You must've divided by zero or entered something that's not an Int. Try again!
/ by zero



  




</pre>


