---
layout: default
title: Machine Learning in Action::k-近邻算法（kNN）
---

<h2>{{ page.title }}</h2>

<hr />

<h3> KNN-概述 </h3>

<pre>
	关键词：分类·监督学习

	原理：基于特征距离的最相近样本的等权重投票制。
	简单来讲：存在一个样本数据集合（训练集），样本中的每一条数据都存在一个标签（所属分类）。预测数据集合是仅有特征数据没有标签的数据集合。
		对于预测集的每一条数据，我们均可以将其与样本集合中的数据在特征空间进行距离计算，挑选出与之距离最相近的K个样本数据。然后这K个
		样本数据中，出现次数最多的分类即为我们要预测的那个分类。
	缺点：显而易见，计算的时间复杂度与空间复杂度均较高。
</pre>

<hr />

<h3> kNN-算法实现 </h3>

<code>
def classify0(intX,dataSet,labels,k):<br/>
	dataSetSize = dataSet.shape[0]<br/>
	diffMat = tile(intX,(dataSetSize,1)) - dataSet<br/>
	sqDiffMat = diffMat**2<br/>
	sqDistances = sqDiffMat.sum(axis = 1)<br/>
	distances = sqDistances**0.5<br/>
	sortedDistIndicies = distances.argsort()<br/>
	classCount = {}<br/>
	for i in range(k):<br/>
		voteILabel = labels[sortedDistIndicies[i]]<br/>
		classCount[voteILabel] = classCount.get(voteILable,0) + 1<br/>
	sortedClassCount = sorted(classCount.iteritems(),key = operator.itemgetter(1),reverse=True)<br/>
	return sortedClassCount[0][0]<br/>
</pre>
</code>


