---
layout: default
title: VLC分析记录
---

<h2>{{ page.title }}</h2>

<hr>

<h3>Schedual</h3>

<ol>
<li>1</li>
</ol>

<hr>

<h3> Details: </h3>

<h4></h4>
<pre>

1 JNI(Java Native Interface)
	本地库接口。
	VLC的内核引擎主要还是集中于 libvlc,libcore等库构建的。这部分在 /vlc/ 下的

2 android.mk 是关键。探索整个工程的构建，从底层库到java层。

3 对src/org.videolan.vlc.gui.video.VideoPlayerActivity.java的分析看

	mLibVLC ( an instance of LibVLC.class)是控制整个播放的关键。先阶段的思路是从mLibVLC 入手

4 分析 LibVLC.java

     /*
             * Set higher caching values if using iomx decoding, since some omx
             * decoders have a very high latency, and if the preroll data isn't
             * enough to make the decoder output a frame, the playback timing gets
             * started too soon, and every decoded frame appears to be too late.
             * On Nexus One, the decoder latency seems to be 25 input packets
             * for 320x170 H.264, a few packets less on higher resolutions.
             * On Nexus S, the decoder latency seems to be about 7 packets.
             */

    latency : 延迟   preroll:  前滚 timing :


5 视频基本原理 
	播放一个视频分为四个步骤：
	
	1 access 访问 ：理解为获取，接收，得到
	2 demux  解复用：就是把通常合在一起的音频和视频分离（还有可能有字幕）
	3 decode 解码：包括音频视频的解码
	4 output 输出 ：包括音频(aout)和视频(vout)的输出

	ES PES TS

6 流媒体跟踪

	1. 'libvlc_new' : libvlc_instance_t * libvlc_new( int argc, const char *const *argv ) [in /vlc/lib/core.c]

7 vlc 代码分析（not for android）
  
7.1  Libvlc 是vlc的核心，它是一个提供接口的库，比如给vlc 提供某些功能接口：流的接入，音频和视频输出，插件管理，线程系统。所有的LibVlc源码位于vlc/src/及其子目录：
	interface/:包含与用户交互的代码，如按键和设备弹出。
		-----dialog.c  interface.c
        playlist/: 管理播放列表的交互，如停止，播放，下一个，或者随机播放。
                          ××××   msg_Dbg( obj, "corks count: %"PRId64" -> %"PRId64, old.i_int, cur.i_int );  ---打印调试
		-----aout.c  art.c  art.h  control.c  engine.c  fetcher.c  fetcher.h  item.c  loadsave.c  playlist_internal.h  preparser.c  preparser.h  search.c  services_discovery.c  sort.c  thread.c  tree.c
	input/:代开一个输入组件，读包，解析她们并且将被还原的基本流传递给解码器
		----access.c  clock.h    decoder.h          demux.h   es_out_timeshift.c  event.h  input_interface.h  item.h      resource.h  stream_demux.c   stream_memory.c  vlm.c        vlm_internal.h
		    access.h  control.c  decoder_synchro.c  es_out.c  es_out_timeshift.h  info.h   input_internal.h   meta.c      stats.c     stream_filter.c  subtitles.c      vlm_event.c  vlmshell.c
		    clock.c   decoder.c  demux.c            es_out.h  event.c             input.c  item.c             resource.c  stream.c    stream.h         var.c            vlm_event.h
	video_output/：初始化video显示器，从解码器得到所有的图片和子图片（如subtitle),随意将她们转换为其他格式（如：YUV到RGB)并且播放
		----chrono.h   control.h  display.h  inhibit.c  interlacing.c  opengl.c    snapshot.h   video_epg.c     video_text.c     vout_control.h   vout_intf.c         vout_wrapper.c
		    control.c  display.c  event.h    inhibit.h  interlacing.h  snapshot.c  statistic.h  video_output.c  video_widgets.c  vout_internal.h  vout_subpictures.c  window.c
	audio_output/: 初始化音频mixer(混合器）。如发现正确的播放频率，然后重新制作从解码器接受过来的音频。
		----aout_internal.h  common.c  dec.c  filters.c  output.c  volume.c
	stream_output/: 类似audio_output
		---sap.c  sdp.c  stream_output.c  stream_output.h
	misc/:被libvlc其他部分使用的杂项，如线程系统，消息队列，cpu探测，对象查询系统，或者特定平台代码
		---addons.c  epg.c        events.c  filter_chain.c   http_auth.c    md5.c       mtime.c    picture_fifo.c  rand.c        text_style.c  update_crypto.c  variables.h
			block.c   error.c      exit.c    fingerprinter.c  httpcookies.c  messages.c  objects.c  picture_pool.c  subpicture.c  threads.c     update.h         xml.c
			cpu.c     es_format.c  filter.c  fourcc.c         image.c        mime.c      picture.c  probe.c         subpicture.h  update.c      variables.c

7.2 vlc基本是围绕着libVLC写成的程序。

7.3 组件。组件基本位于 module\子目录，在运行时被加载，每个组件提供不同的特性适应特定的文件环境。另外大量的不断编写的可移植功能位于 auto_output\ video_output\ interface\等，支持不同平台

------------------------------------------------------------------------------------------------------------------------------------------
</pre>


<h4>追踪状态似乎有眉目了</h4>
<pre>
	感谢<a href='http://blog.csdn.net/vertx/article/details/8647790'>不甘心的阿甘</a>带我走出了死胡同。
	
	手动追踪一下代码
	
	<strong>Java-Level :</strong>
		org.videolan.vlc.LibVLC.java :
			[line 649]   
			/**
     			* Returns true if any media is playing
     			*/
    			public native boolean isPlaying();
		
	<strong>JNI : </strong>
		libvlcjni.c :
			[line 478]
			jboolean Java_org_videolan_libvlc_LibVLC_isPlaying(JNIEnv *env, jobject thiz)
			{
    				libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
    				if (mp)
        			return !!libvlc_media_player_is_playing(mp);
    				else
        			return 0;
			}
	<strong>Native-Level:</strong>
		vlc/lib/media_player.c :
			  930	/**************************************************************************
			  931	 * Tells whether the media player is currently playing.
			  932	 *
			  933	 * Enter with lock held.
 			  934	 **************************************************************************/
			  935	int libvlc_media_player_is_playing( libvlc_media_player_t *p_mi )
			  936	{
  			  937	    libvlc_state_t state = libvlc_media_player_get_state( p_mi );
			  938	    return (libvlc_Playing == state) || (libvlc_Buffering == state);
			  939	}
  			  940
         
		vlc/include/vlc/libvlc_media.h			  		
			/**
			 * Note the order of libvlc_state_t enum must match exactly the order of
			 * \see mediacontrol_PlayerStatus, \see input_state_e enums,
			 * and VideoLAN.LibVLC.State (at bindings/cil/src/media.cs).
			 *
			 * Expected states by web plugins are:
			 * IDLE/CLOSE=0, OPENING=1, BUFFERING=2, PLAYING=3, PAUSED=4,
			 * STOPPING=5, ENDED=6, ERROR=7
			 */
			typedef enum libvlc_state_t
			{
			    libvlc_NothingSpecial=0,
			    libvlc_Opening,
			    libvlc_Buffering,
			    libvlc_Playing,
			    libvlc_Paused,
			    libvlc_Stopped,
			    libvlc_Ended,
			    libvlc_Error
			} libvlc_state_t;



我们可以自己去定义一些状态函数，然后进行监听，具体可以参考 上面那个链接的前辈的思路


-------------------------------------------------------------------------------------------

</pre>

<h4>继续追踪源代码</h4>


<pre>

android/vlc/lib/media_player.c :
	[line 893]:	void libvlc_media_player_set_pause( libvlc_media_player_t *p_mi, int paused )
			{
	………………
	[line 899]:		    libvlc_state_t state = libvlc_media_player_get_state( p_mi );
	
	
所有跟媒体有关的，比如 长度，播放时间，都跟 p_input_thread (input_thread_t* 类型)




android/vlc/lib/media.c :

/**************************************************************************
 * Getter for statistics information
 **************************************************************************/
int libvlc_media_get_stats( libvlc_media_t *p_md,
                            libvlc_media_stats_t *p_stats )
{
    if( !p_md->p_input_item )
        return false;

    input_stats_t *p_itm_stats = p_md->p_input_item->p_stats;
    vlc_mutex_lock( &p_itm_stats->lock );
    p_stats->i_read_bytes = p_itm_stats->i_read_bytes;
    p_stats->f_input_bitrate = p_itm_stats->f_input_bitrate;

    p_stats->i_demux_read_bytes = p_itm_stats->i_demux_read_bytes;
    p_stats->f_demux_bitrate = p_itm_stats->f_demux_bitrate;
    p_stats->i_demux_corrupted = p_itm_stats->i_demux_corrupted;
    p_stats->i_demux_discontinuity = p_itm_stats->i_demux_discontinuity;

    p_stats->i_decoded_video = p_itm_stats->i_decoded_video;
    p_stats->i_decoded_audio = p_itm_stats->i_decoded_audio;

    p_stats->i_displayed_pictures = p_itm_stats->i_displayed_pictures;
    p_stats->i_lost_pictures = p_itm_stats->i_lost_pictures;

    p_stats->i_played_abuffers = p_itm_stats->i_played_abuffers;
    p_stats->i_lost_abuffers = p_itm_stats->i_lost_abuffers;

    p_stats->i_sent_packets = p_itm_stats->i_sent_packets;
    p_stats->i_sent_bytes = p_itm_stats->i_sent_bytes;
    p_stats->f_send_bitrate = p_itm_stats->f_send_bitrate;
    vlc_mutex_unlock( &p_itm_stats->lock );
    return true;
}i


<strong>看来许多重要的API集中于 vlc/lib/</strong>


------------------------------------

记录一条跟踪：

这次在机器上尝试着打开德国DASH服务器上的视频，卡顿了，看了一下log 大概如下



追踪了一下源码：
jangwee@jangwee-OptiPlex-3020:~/workspace/wp_android$ grep "picture is too late to be displayed" * -r
匹配到二进制文件 android/vlc-android/obj/local/armeabi-v7a/libvlcjni.so
匹配到二进制文件 android/vlc-android/libs/armeabi-v7a/libvlcjni.so
匹配到二进制文件 android/vlc/build-android-arm-linux-androideabi/src/video_output/video_output.o
匹配到二进制文件 android/vlc/build-android-arm-linux-androideabi/src/.libs/libvlccore.a
android/vlc/src/video_output/video_output.c:                        msg_Warn(vout, "picture is too late to be displayed (missing %"PRId64" ms)", late/1000);

在video_output.c文件里。

   815	static int ThreadDisplayPreparePicture(vout_thread_t *vout, bool reuse, bool frame_by_frame)
   816	{
   817	    bool is_late_dropped = vout->p->is_late_dropped && !vout->p->pause.is_on && !frame_by_frame;
   818	
   819	    vlc_mutex_lock(&vout->p->filter.lock);
   820	
   821	    picture_t *picture = filter_chain_VideoFilter(vout->p->filter.chain_static, NULL);
   822	    assert(!reuse || !picture);
   823	
   824	    while (!picture) {
   825	        picture_t *decoded;
   826	        if (reuse && vout->p->displayed.decoded) {
   827	            decoded = picture_Hold(vout->p->displayed.decoded);
   828	        } else {
   829	            decoded = picture_fifo_Pop(vout->p->decoder_fifo);
   830	            if (decoded) {
   831	                if (is_late_dropped && !decoded->b_force) {
   832	                    const mtime_t predicted = mdate() + 0; /* TODO improve */
   833	                    const mtime_t late = predicted - decoded->date;
   834	                    if (late > VOUT_DISPLAY_LATE_THRESHOLD) {
   835	                        msg_Warn(vout, "picture is too late to be displayed (missing %"PRId64" ms)", late/1000);
   836	                        picture_Release(decoded);
   837	                        vout_statistic_AddLost(&vout->p->statistic, 1);
   838	                        continue;
   839	                    } else if (late > 0) {
   840	                        msg_Dbg(vout, "picture might be displayed late (missing %"PRId64" ms)", late/1000);
   841	                    }
   842	                }
   843	                if (!VideoFormatIsCropArEqual(&decoded->format, &vout->p->filter.format))
   844	                    ThreadChangeFilters(vout, &decoded->format, vout->p->filter.configuration, true);
   845	            }
   846	        }
   847	
   848	        if (!decoded)
   849	            break;
   850	        reuse = false;
   851	
   852	        if (vout->p->displayed.decoded)
   853	            picture_Release(vout->p->displayed.decoded);
   854	
   855	        vout->p->displayed.decoded       = picture_Hold(decoded);
   856	        vout->p->displayed.timestamp     = decoded->date;
   857	        vout->p->displayed.is_interlaced = !decoded->b_progressive;
   858	
   859	        picture = filter_chain_VideoFilter(vout->p->filter.chain_static, decoded);
   860	    }
   861	
   862	    vlc_mutex_unlock(&vout->p->filter.lock);
   863	
   864	    if (!picture)
   865	        return VLC_EGENERIC;
   866	
   867	    assert(!vout->p->displayed.next);
   868	    if (!vout->p->displayed.current)
   869	        vout->p->displayed.current = picture;
   870	    else
   871	        vout->p->displayed.next    = picture;
   872	    return VLC_SUCCESS;
   873	}
   874	

--------------------------------------------------------------------------------------------


同时，追踪了一下 <strong>core input: Buffering 30%</strong>


</pre>

<h4>JNI 部分</h4>

<pre>

------------------------------------libvlc-track.c
[line 268] jobject Java_org_videolan_libvlc_LibVLC_getStats(JNIEnv *env, jobject thiz):
	似乎是得到的统计信息,返回一个hash表


</pre>


<h4>Java层可以改动部分</h4>

<pre>
	VideoPlayerActivity.java :
[line 945] :
 /**
     *  Handle libvlc asynchronous events
 */

感觉可以从这里入手.
这个地方是处理事件的入口，那么从哪抛出的事件呢？

在libvlcjni.c ：
[line 122] static void vlc_event_callback(const libvlc_event_t *ev, void *data) 

[line 400] Java_org_videolan_libvlc_LibVLC_playMRL 调用上面的本地方法

注意
在EventHandler.java :
[line 122]    
 /** This method is called by a native thread **/
    public void callback(int event, Bundle b) {

说明 JNI 回调了Java层的方法，post 消息

在jni/下检索 : 

jangwee@jangwee-OptiPlex-3020:~/workspace/wp_android/android/vlc-android/jni$ grep '"callback"' -n -r *
libvlcjni.c:197:    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILandroid/os/Bundle;)V");
libvlcjni-util.c:142:    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILandroid/os/Bundle;)V");




</pre>



<h3>方案</h3>
<pre>
	1 vlc 播放 android平台demo (js 备选)
	2 前期自己部署服务器，去get  后期 可以利用VParse 去解析地址，然后http get
	3 参数采集：
		3.1 寻找工具，
		3.2 抓包，分析 时延，
			eg ping -c

			网速测试 android::TrafficStats 类
	4 在url的消息触发之后，hook住它，Vparse 地址，然后调用本地程序。
 
</pre>


<h4>key words</h4>
<pre>

1MPEG-TS流


2 源码中涉及到一些C技巧。
	2.1宏 结构体 实现继承
	2.2
	static int RandomCallback( vlc_object_t *p_this, char const *psz_cmd,
                           vlc_value_t oldval, vlc_value_t newval, void *a )
	{
    		(void)psz_cmd; (void)oldval; (void)newval; (void)a;


	这一句有什么作用呢？
	请教之后，因为这三个变量在这个函数中都没有用到，所以当编译器警告级别开到最大的时候，会输出编译警告，告诉你这些变量可能没被引用。
	所以所，这样的话，就相当告诉编译器我用过了。
	我猜测，接口这样设计，可能是为了将来扩展好用。

        	


</pre>

<hr />

<p> Welcome to contact <a href="mailto:jangwee1@sina.com.cn">me</a>,the friends who like Machine-Learning and Data-Mining.</p>
<p> <a href=freedom.png>:)</a></p>

<p>{{ page.date | date_to_string }}</p>


